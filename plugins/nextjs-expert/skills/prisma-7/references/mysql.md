---
name: mysql
description: MySQL database specifics, native types, connection pooling, and limitations in Prisma 7
when-to-use: MySQL database configuration, native types, connection pooling, compatibility issues
keywords: MySQL, native types, connection pooling, serverless, limitations
priority: high
requires: schema.md, connection-pooling.md, field-attributes.types.md
related: planetscale.md, driver-adapters.md, deployment.md
---

# MySQL Features

Type definitions in `/plugins/nextjs-expert/skills/prisma-7/references/interfaces/field-attributes.types.md`.

MySQL-specific configuration and features in Prisma 7.

## Native Types

See `DatabaseType` in `/plugins/nextjs-expert/skills/prisma-7/references/interfaces/field-attributes.types.md`

```prisma
model Product {
  id          String   @id @default(cuid())
  name        String   @db.VarChar(255)
  description String   @db.LongText
  price       Decimal  @db.Decimal(10, 2)
  status      String   @db.Enum("active", "inactive", "pending")
  metadata    Json
  createdAt   DateTime @db.DateTime
}
```

```typescript
/**
 * MySQL native type mapping for Prisma fields.
 * @typedef {Object} MySQLNativeTypes
 * @property {string} varChar - MySQL VARCHAR type with length constraint
 * @property {string} text - MySQL TEXT type for medium text (64KB)
 * @property {string} longText - MySQL LONGTEXT type for large text (4GB)
 * @property {string} decimal - MySQL DECIMAL(p,s) for precise numbers
 * @property {string} enum - MySQL ENUM for fixed set of values
 * @property {string} dateTime - MySQL DATETIME type for timestamps
 * @module modules/database/src/interfaces/field-attributes.types
 */
type MySQLNativeTypes = {
  varChar: string;
  text: string;
  longText: string;
  decimal: string;
  enum: string;
  dateTime: string;
}
```

---

## Common MySQL Types

| Prisma Type | MySQL Type | Usage |
|-------------|-----------|-------|
| `String @db.VarChar(n)` | `varchar(n)` | Strings up to n chars |
| `String @db.Text` | `text` | Medium text (64KB) |
| `String @db.LongText` | `longtext` | Large text (4GB) |
| `String @db.Enum(...)` | `enum` | Fixed set of values |
| `Decimal @db.Decimal(p,s)` | `decimal(p,s)` | Precise numbers |
| `DateTime @db.DateTime` | `datetime` | Timestamp |
| `DateTime @db.Timestamp` | `timestamp` | Auto-managed timestamp |

---

## ENUM Fields

```prisma
model Order {
  id     String @id @default(cuid())
  status OrderStatus

  @@map("orders")
}

enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED

  @@map("order_status")
}
```

```typescript
/**
 * Type-safe enum query using Prisma ORM.
 * @param {string} orderId - Order identifier
 * @returns {Promise<{status: OrderStatus}>} Order with typed status field
 * @module modules/database/src/services/orders
 */
async function getOrderStatus(orderId: string) {
  const order = await prisma.order.findUnique({
    where: { id: orderId },
  })
  // order.status is typed as OrderStatus
  return order
}
```

---

## Connection Pooling

```env
# .env - Connection URL with pooling
DATABASE_URL="mysql://user:password@localhost:3306/dbname?schema=public"

# Add pool parameters for serverless
DATABASE_URL="mysql://user:password@localhost:3306/dbname?schema=public&connection_limit=10"
```

---

## Limitations

### 1. No Native UUID

```typescript
/**
 * MySQL lacks native UUID support, use cuid() or nanoid() instead.
 * See `IdentityType` in /plugins/nextjs-expert/skills/prisma-7/references/interfaces/field-attributes.types.md
 * @typedef {Object} UserIdentity
 * @property {string} id - Primary key using CUID generator
 * @module modules/database/src/services/users
 */
type UserIdentity = {
  id: string; // Generated by cuid() not UUID
}
```

### 2. Limited JSON Support

```typescript
/**
 * MySQL JSON support is limited compared to PostgreSQL JSONB.
 * Use only for non-queryable metadata.
 * @typedef {Object} SettingsModel
 * @property {string} id - Primary key
 * @property {Record<string, unknown>} metadata - JSON metadata field
 * @module modules/database/src/interfaces/field-attributes.types
 */
type SettingsModel = {
  id: string;
  metadata: Record<string, unknown>;
}

/**
 * Query settings with limited JSON filtering capabilities.
 * @param {string} settingsId - Settings identifier
 * @returns {Promise<SettingsModel>} Settings record
 * @module modules/database/src/services/settings
 */
async function getSettings(settingsId: string) {
  return await prisma.settings.findMany({
    where: { id: settingsId },
  })
}
```

### 3. No Native Arrays

```typescript
/**
 * MySQL doesn't support native array types.
 * Use JSON field as workaround.
 * See `DatabaseType` in /plugins/nextjs-expert/skills/prisma-7/references/interfaces/field-attributes.types.md
 * @typedef {Object} UserWithTags
 * @property {string} id - Primary key
 * @property {string[]} tags - Tags stored as JSON array
 * @module modules/database/src/services/users
 */
type UserWithTags = {
  id: string;
  tags: string[]; // Stored as JSON: ["tag1", "tag2"]
}
```

---

## MySQL 8.0+ Features

```typescript
/**
 * MySQL 5.7+ generated columns for computed fields.
 * See `DefaultValueConfig` in /plugins/nextjs-expert/skills/prisma-7/references/interfaces/field-attributes.types.md
 * @typedef {Object} ProductWithComputed
 * @property {string} id - Primary key
 * @property {string} firstName - First name
 * @property {string} lastName - Last name
 * @property {string} fullName - Generated column from firstName + lastName
 * @module modules/database/src/services/products
 */
type ProductWithComputed = {
  id: string;
  firstName: string;
  lastName: string;
  fullName: string; // CONCAT(firstName, ' ', lastName)
}
```

---

## Best Practices

1. **Use VARCHAR with limits** - Performance critical
2. **Prefer TIMESTAMP** - Simpler than DATETIME
3. **Avoid JSON** - For complex queries, use PostgreSQL
4. **Use connection pooling** - Essential for serverless
5. **ENUM fields** - Type-safe status fields
